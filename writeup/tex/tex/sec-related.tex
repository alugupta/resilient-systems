\section{Related Work}
\label{sec-related}

We organize the related work surrounding efficient, low-cost memory protection
techniques in two separate sections : \textbf{memory encryption} and
\textbf{memory integrity verification}.

\subsection{Memory Encryption}
The goal of memory encryption techniques is to protect the confidentiality of
sensitive information from unauthorized subjects. Sensitive information
includes : secret keys, secret code (e.g. proprietary boot code) and private
data. The \TT{National Institute of Standards and Technology} (NIST) actively
regulates the encryption standards. Recently, two symmetric key cryptographic
algorithms are being increasingly used in trusted computing : Triple Data
Encryption Standard (3DES) and Advanced Encryption Standard/Rjindael (AES). As
AES provides systems with a higher minimum security strength, it is more widely
used in recent hardware accelerated trusted computing studies as compared to
3DES. For instance, Intel has developed extensions to it's instruction set
architecture (ISA) to enable fast encryption and decryption using AES. The
studies in this survey focus on using AES to develop efficient, low-cost
encryption and decryption modules.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{AES Counter Mode Encryption}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
AES supports three general modes of operation: Electronic Codebook (ECB),
Cipher Block Chaining (CBC) and Counter (CTR). Since the AES-ECB mode preserves
patterns from the plaintext to the ciphertext, it does not provide adequate
confidentiality protection. Both AES-CBC and AES-CTR eliminate this information
leak by chaining the encryption between blocks. This however precludes users
from encrypting and decrypting blocks in parallel (as supported by AES-ECB). As
discussed in \cite{suh-memIntEnc}, decrypting the ciphertext stored in memory
can drastically increase the load use delay latency of processing systems. The
added latency is a result of the serial : fetch memory then decrypt memory
block operation. To hide this latency Suh et. al. use a \TT{one-time pad} (OTP)
based encryption / decryption technique. The OTP is generated by encrypting the
plaintext = {\TT{FV} $||$ \TT{Addr} $||$ \TT{TS} $||$ \TT{i}}, under a secret
key using AES-CTR. \TT{FV} is a fixed vector, \TT{Addr} is the memory address
being accessed, \TT{TS} is a timestamp stored along with the encrypted data and
\TT{i} is the block number. The use of a monotonically incrementing counter,
\TT{TS}, ensures the uniqueness of the \TT{OTP} which is then proven to be
secure. Generating the \TT{OTP} using this method enables the system to overlap
the AES-CTR decryption latency with the memory fetch / accessing latency
\cite{suh-memIntEnc}. Suh et. al. also mentions the \TT{TS} values can be
cached to mitigate the memory access latency for fetching the \TT{TS} and
better hiding the AES-CTR decryption latency. This method reduces the
load-use-delay latency to the latency of performing an $\oplus$ between the
generated \TT{OTP} and encrypted data.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{AEGIS}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Furthering the AES-CTR based decryption \cite{suh-memIntEnc}, AEGIS
\cite{aegis} adds low-level OS-kernel support to provide additional
confidentiality features. AEGIS, a single-chip secure processor, leverages
OS-kernel modes to provide additional encryption (ME mode) and
integrity-verification (IV mode) features. The OS also manages four distinct
protected regions in virtual memory

\begin{enumerate}[noitemsep, topsep=0pt]
    \item Read-only (static) verified memory
    \item Read-write (static) verified memory
    \item Read-only (dynamic) private memory
    \item Read-write (dynamic) private memory
\end{enumerate}

These modes help isolate the virtual memory space of each process to ensure
that secret keys are kept confidential across multiple users and between users
and the supervisor. AEGIS also employs physically random functions (also called
physically unclonable functions) to secret keys as they are less prone to
physical hardware attacks than the alternatives such as using non-volatile
memory (e.g. EEPROM) and fuses.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Duece}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Thread Model : Snooping and DIMM read attack

Need to consider the following:
\begin{enumerate}
  \item Without encryption, most writes only change around 12 \% of bits.
  \item \textbf{Avalance Effect} \cite{avalance} - Even changing 1 bit can
    change the entry encrypted bitstring : 1 bit causes 50\% of bits on average
    to change.
  \item Cannot use techniques such as \TT{Data Comparison Write} \cite{dcr} and
    \TT{Flip-n-Write} \cite{fnw} to reduce bit's written.
  \item This affects power consumption as now all the bits must be written.
  \item This affects write durability of memory as memory writes will causes
    memory to wear out faster (more bits written - 4x more on average)
\end{enumerate}
Used non-volatile memory (PCM).
\begin{enumerate}
  \item Dual Counter Encryption : Leading and Trailing Counters.
  \item Only encrypt modified elements under Leading counter and everything
    else using trailing counter.
  \item This reduces memory writes from 50 \% to 24 \% on average.
  \item Also enable the option to dynamically swtich to \TT{Flip-n-Write} mode
    if all the bits in the chance block / line are changing.
  \item Decrease power significantly.
  \item Only have the added overhead of 1 bit per encryption level. Tells if
    the block was encrypted in the current Epoch.
  \item To eliminate wear leveling (only certain cache blocks being written to
    usually) they also implemented an efficient horizontal wear leveling
    technique that uses algebraic functions to calcuate the rotation level.
\end{enumerate}

\subsubsection{GCM Based}
The GCM based approach \cite{gcmMem} uses a split counter mode in this
encryption and decryption routines. The split counter maintains two counters :
major and minor counter. The major counter is unqiue per encryption page and
minor counter per block. There are appoximately 8 bits in the minor counter and
64 bits in the major counter. The major and minor are concatenated to make the
counter for the encryption. GCM is secure like AES and highly efficient /
parallel.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Integrity}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Merkle}
Merkle trees \cite{merkle} are the idea of using a hash tree to store the
authentication tags and reduce the \TT{integrity check} from a linear
relationship of the number of memory operation to a logarithmic one. Many
techniques have been used to reduce the architectural overhead of this
including the arity of the hash tree, the granularity of the authentication and
maintaining a cache for the hashes. This can be problematic though as
maintaining the cache is complex and if it is combined with the data cache, it
can severely increase miss rates and pollute the cache. Also, an efficient
improvement is to only check until a node is the cache tree that is known to be
trusted is verified (which is in the cache).

\subsubsection{Suh - Efficient Memory Integrity and Encryption}
Mainly focuses on integrity with log based hash tables. It keeps a log of a
sequence of memory operations to maintain a snapshot of the current state of
the memory. This is considered \TT{lazy} memory integrity management because it
only detects the malliciously modified memory much after the attack (possibly)
since the authentication scheme only acts very intermittently.

\TT{Integrity verification} - Cache Hash Tree approach or the Log based
  approach discussed in \cite{suh-memIntEnc}. Log based is more efficient in
  terms of performance and space requried.

\subsubsection{Suh - AEGIS}
Develops a single-core processor extension, AEGIS, \cite{aegis} to provide
security features. AEGIS leverages Physical Random Functions (PRF) and off-chip
memory protection. For memory integrity protection there is defined by specific
operating modes (PTR and TE). Memory pages can be defined to be under
plaintext, integrity, confidentiality and or both protection.

\subsubsection{GCM Based}
The GCM based approach uses the GMAC / GHASH functions to provide memory
authentication capabilities. They do not use MD-5 or SHA-1, SHA-2 as they are
much more computationally intensive and incur a high latency. They use the idea
of Merkle trees to do the \TT{integrity} check but hide the fetch latency using
caches and authentication computation. The authentication also generates pads
which can be hidden in the memory access latency and finally XOR's these pads
with the data (plaintext for authenticated and ciphertext for verifying) like
the counter mode. Parallelize the Merkle tree to hide that latency as well.

\subsubsection{Multi-Core}
The multicore paper \cite{multicoreEnc} discusses how traditional Merkle tree
approaches do not work for multiprocessor systems. They instead have a single
global MAC tree managed by the memory controller. They also rely on having a
secure OS kernel which manages session keys which are used to generate secret
keys.
